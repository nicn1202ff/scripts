-- [[ This script was made by MelonScripter/Melon/Cherry and Makhail107 ]] --
-- [[ Reanimate was made by MyWorld, and edited by Epic/Melon ]] --
-- [[ Handmaking animations is hell... - Melon ]] --
--[[

https://www.roblox.com/catalog/9867487176/Le-Rouge-Cross-body-Bag-3-0
https://www.roblox.com/catalog/9867481700/Le-Rouge-Cross-body-Bag-1-0
https://www.roblox.com/catalog/8763290412/Warrior-Mat-Alo-Yoga-Strap-Black -- CAN BE ANY YOGA MAT!
https://www.roblox.com/catalog/8763318146/Warrior-Mat-Alo-Yoga-Strap-Jungle -- CAN BE ANY YOGA MAT!
https://www.roblox.com/catalog/4819740796/Robox
https://www.roblox.com/catalog/10775031176/The-Pogo

]]--

--[[

loadstring(game:HttpGet("https://pastebin.com/raw/AbCPzg6t"))()

local Rockerfeller = Instance.new("Sound", Workspace)
local RockerfellerName = "Rockerfeller.mp3"
  if not isfile&#40;RockerfellerName&#41; then
writefile&#40;RockerfellerName, game:HttpGet("https://download850.mediafire.com/ree2c3lfg61gr6BOBwofRxVbHCSqEoQ8epDlJl5gdJsDaNl_Sx1e46JPZTB3cM2hQ9qhZJaOMZ0KN3xyzeKD7Xou3RmKluQTOzPfD-A_K47wOWTDfSqsjDyuRarNrIfsw9JHonlfU85R05km2AlQyCxy_x8792xzgmyfONcedGMFJA/2as8p30yr7n60pn/Lightning+cannon+v1.mp3"&#41;)
end
Rockerfeller.SoundId = syn and getsynasset(RockerfellerName) or getcustomasset(RockerfellerName)
Rockerfeller.EmitterSize = math.huge
Rockerfeller.MaxDistance = math.huge
Rockerfeller.Looped = true
Rockerfeller.Pitch = 1
Rockerfeller.Name = "Sound"
Rockerfeller.Volume = 100
]]--

local Sinner = Instance.new("Sound", Workspace)
local SinnerName = "Sinner.mp3"
  if not isfile&#40;SinnerName&#41; then
writefile&#40;SinnerName, game:HttpGet("https://download850.mediafire.com/ree2c3lfg61gr6BOBwofRxVbHCSqEoQ8epDlJl5gdJsDaNl_Sx1e46JPZTB3cM2hQ9qhZJaOMZ0KN3xyzeKD7Xou3RmKluQTOzPfD-A_K47wOWTDfSqsjDyuRarNrIfsw9JHonlfU85R05km2AlQyCxy_x8792xzgmyfONcedGMFJA/2as8p30yr7n60pn/Lightning+cannon+v1.mp3"&#41;)
end
Sinner.SoundId = syn and getsynasset(SinnerName) or getcustomasset(SinnerName)
Sinner.EmitterSize = math.huge
Sinner.MaxDistance = math.huge
Sinner.Looped = true
Sinner.Pitch = 1.1
Sinner.Name = "Sound"
Sinner.Volume = 1
Sinner:Play()

local Infected = Instance.new("Sound", Workspace)
local InfectedName = "Infected.mp3"
  if not isfile&#40;InfectedName&#41; then
writefile&#40;InfectedName, game:HttpGet(""&#41;)
end
Infected.SoundId = syn and getsynasset(InfectedName) or getcustomasset(InfectedName)
Infected.EmitterSize = math.huge
Infected.MaxDistance = math.huge
Infected.Looped = true
Infected.Pitch = 1.02
Infected.Name = "Sound"
Infected.Volume = 1

local Abyst = Instance.new("Sound", Workspace)
local AbystName = "Abyst.mp3"
  if not isfile&#40;AbystName&#41; then
writefile&#40;AbystName, game:HttpGet("https://download850.mediafire.com/ree2c3lfg61gr6BOBwofRxVbHCSqEoQ8epDlJl5gdJsDaNl_Sx1e46JPZTB3cM2hQ9qhZJaOMZ0KN3xyzeKD7Xou3RmKluQTOzPfD-A_K47wOWTDfSqsjDyuRarNrIfsw9JHonlfU85R05km2AlQyCxy_x8792xzgmyfONcedGMFJA/2as8p30yr7n60pn/Lightning+cannon+v1.mp3"&#41;)
end
Abyst.SoundId = syn and getsynasset(AbystName) or getcustomasset(AbystName)
Abyst.EmitterSize = math.huge
Abyst.MaxDistance = math.huge
Abyst.Looped = true
Abyst.Pitch = 1.1
Abyst.Name = "Sound"
Abyst.Volume = 1

local Rockerfeller = Instance.new("Sound", Workspace)
local RockerfellerName = "Rockerfeller.mp3"
  if not isfile&#40;RockerfellerName&#41; then
writefile&#40;RockerfellerName, game:HttpGet("https://download850.mediafire.com/ree2c3lfg61gr6BOBwofRxVbHCSqEoQ8epDlJl5gdJsDaNl_Sx1e46JPZTB3cM2hQ9qhZJaOMZ0KN3xyzeKD7Xou3RmKluQTOzPfD-A_K47wOWTDfSqsjDyuRarNrIfsw9JHonlfU85R05km2AlQyCxy_x8792xzgmyfONcedGMFJA/2as8p30yr7n60pn/Lightning+cannon+v1.mp3"&#41;)
end
Rockerfeller.SoundId = syn and getsynasset(RockerfellerName) or getcustomasset(RockerfellerName)
Rockerfeller.EmitterSize = math.huge
Rockerfeller.MaxDistance = math.huge
Rockerfeller.Looped = true
Rockerfeller.Name = "Sound"
Rockerfeller.Volume = 1

local KillBot = Instance.new("Sound", Workspace)
local KillBotName = "KillBot.mp3"
  if not isfile&#40;KillBotName&#41; then
writefile&#40;KillBotName, game:HttpGet("https://download850.mediafire.com/ree2c3lfg61gr6BOBwofRxVbHCSqEoQ8epDlJl5gdJsDaNl_Sx1e46JPZTB3cM2hQ9qhZJaOMZ0KN3xyzeKD7Xou3RmKluQTOzPfD-A_K47wOWTDfSqsjDyuRarNrIfsw9JHonlfU85R05km2AlQyCxy_x8792xzgmyfONcedGMFJA/2as8p30yr7n60pn/Lightning+cannon+v1.mp3"&#41;)
end
KillBot.SoundId = syn and getsynasset(KillBotName) or getcustomasset(KillBotName)
KillBot.EmitterSize = math.huge
KillBot.MaxDistance = math.huge
KillBot.Looped = true
KillBot.Pitch = 0.95
KillBot.Name = "Sound"
KillBot.Volume = 1

game:GetService("StarterGui"):SetCore("SendNotification", { 
 Title = "Melon's (FE) Converts/Scripts";
 Text = "Loaded successfully!";
  Ic
 Durati


--The reality of my life isn't real but a Universe -makhail07
wait(0.2)
local plr = game:service'Players'.LocalPlayer
Plr = plr
plr.Character.Animate:Destroy()
local char = Plr.Character

local BBoard = Instance.new("BillboardGui", char.Head)
BBoard.Adornee = char.Head
BBoard.StudsOffset = Vector3.new(-6, 4, 0)
BBoard.Size = UDim2.new(4,0,2,0)

local ModeName = Instance.new("TextLabel", BBoard)
ModeName.Text = "Sinner"
ModeName.BackgroundTransparency = 1
ModeName.TextScaled = true
ModeName.TextStrokeTransparency = 0
ModeName.TextStrokeColor3 = Color3.fromRGB(255,255,255)
ModeName.Size = BBoard.Size
 ModeName.F
ModeName.TextColor3 = Color3.fromRGB(0,0,0)

local omgitskorn =  Instance.new("Highlight")  
omgitskorn.Parent = char
omgitskorn.FillColor = Color3.fromRGB(0,0,0)
omgitskorn.FillTransparency = 1
omgitskorn.OutlineColor = Color3.fromRGB(255,255,255)

local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)

cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
Mode = 1
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 


RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
vt = Vector3.new
Effects = {}

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 90
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()
 
game:GetService("RunService").Heartbeat:connect(function(s, p)
 tf = tf + s
 if tf >= frame then
  if allowframeloss then
   script.Heartbeat:Fire()
   lastframe = tick()
  else
   for i = 1, math.floor(tf / frame) do
    script.Heartbeat:Fire()
   end
   lastframe = tick()
  end
  if tossremainder then
   tf = 0
  else
   tf = tf - frame * math.floor(tf / frame)
  end
 end
end)

function swait(num)
 if num == 0 or num == nil then
  game:service("RunService").Stepped:wait(0)
 else
  for i = 0, num do
   game:service("RunService").Stepped:wait(0)
  end
 end
end
function thread(f)
 coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
 local qa = {
  QuaternionFromCFrame(a)
 }
 local qb = {
  QuaternionFromCFrame(b)
 }
 local ax, ay, az = a.x, a.y, a.z
 local bx, by, bz = b.x, b.y, b.z
 local _t = 1 - t
 return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
 local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
 local trace = m00 + m11 + m22
 if trace > 0 then
  local s = math.sqrt(1 + trace)
  local recip = 0.5 / s
  return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
 else
  local i = 0
  if m00 < m11 then
   i = 1
  end
  if m22 > (i == 0 and m00 or m11) then
   i = 2
  end
  if i == 0 then
   local s = math.sqrt(m00 - m11 - m22 + 1)
   local recip = 0.5 / s
   return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
  elseif i == 1 then
   local s = math.sqrt(m11 - m22 - m00 + 1)
   local recip = 0.5 / s
   return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
  elseif i == 2 then
   local s = math.sqrt(m22 - m00 - m11 + 1)
   local recip = 0.5 / s
   return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
  end
 end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
 local xs, ys, zs = x + x, y + y, z + z
 local wx, wy, wz = w * xs, w * ys, w * zs
 local xx = x * xs
 local xy = x * ys
 local xz = x * zs
 local yy = y * ys
 local yz = y * zs
 local zz = z * zs
 return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
 local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
 local startInterp, finishInterp
 if cosTheta >= 1.0E-4 then
  if 1 - cosTheta > 1.0E-4 then
   local theta = math.acos(cosTheta)
   local invSinTheta = 1 / Sin(theta)
   startInterp = Sin((1 - t) * theta) * invSinTheta
   finishInterp = Sin(t * theta) * invSinTheta
  else
   startInterp = 1 - t
   finishInterp = t
  end
 elseif 1 + cosTheta > 1.0E-4 then
  local theta = math.acos(-cosTheta)
  local invSinTheta = 1 / Sin(theta)
  startInterp = Sin((t - 1) * theta) * invSinTheta
  finishInterp = Sin(t * theta) * invSinTheta
 else
  startInterp = t - 1
  finishInterp = t
 end
 return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
 return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end

function FaceMouse()
local Cam = workspace.CurrentCamera
 return {
  CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
  Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
 }
end

local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end

local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local attacktype = 1
local attackdebounce = false
local euler = CFrame.fromEulerAnglesXYZ

hum.WalkSpeed = 8
hum.JumpPower = 57

local ANIMATOR = hum.Animator
ANIMATOR.Parent = nil


local hat2 = gp(cplayer, "PogoStick", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(-0.5, -3, -0.3)
att2.Rotation = Vector3.new(35, 90, 0) --LavanderHair

plr = game.Players.LocalPlayer
mouse = plr:GetMouse()
mouse.KeyDown:connect(function(Key)
if Key == "m" and attack==false and Mode == 1 then
  Mode = 2
  ModeName.Text = "Infected"
  ModeName.TextStrokeColor3 = Color3.fromRGB(255,0,0)
  omgitskorn.OutlineColor = Color3.fromRGB(255,0,0)
  Sinner:Stop()
  Infected:Play()
  att2.Parent = cplayer["Right Arm"]
  att2.Position = Vector3.new(-0.5, -3, -0.3)
        att2.Rotation = Vector3.new(35, 90, 0) --LavanderHair
 elseif Key == "m" and Mode == 2 then
  Mode = 3
  ModeName.Text = "Abyst"
  ModeName.TextStrokeColor3 = Color3.fromRGB(255,255,255)
  omgitskorn.OutlineColor = Color3.fromRGB(255,255,255)
  Infected:Stop()
  Abyst:Play()
        att2.Parent = cplayer["Torso"]
        att2.Position = Vector3.new(0, 0, 1) --LavanderHair
        att2.Rotation = Vector3.new(0, 0, 0) --LavanderHair
  elseif Key == "m" and Mode == 3 then
  Mode = 4
  ModeName.Text = "Rockerfeller"
  ModeName.TextStrokeColor3 = Color3.fromRGB(126, 48, 172)
  omgitskorn.OutlineColor = Color3.fromRGB(126, 48, 172)
  Abyst:Stop()
  Rockerfeller:Play()
  att2.Parent = cplayer["Right Arm"]
  att2.Position = Vector3.new(-0.5, -3, -0.3)
        att2.Rotation = Vector3.new(35, 90, 0) --LavanderHair
  elseif Key == "m" and Mode == 4 then
  Mode = 5
  ModeName.Text = "KillBot"
  ModeName.TextStrokeColor3 = Color3.fromRGB(234,100,145)
  omgitskorn.OutlineColor = Color3.fromRGB(234,100,145)
  Rockerfeller:Stop()
  KillBot:Play()
  att2.Parent = cplayer["Torso"]
        att2.Position = Vector3.new(0, 0, 1) --LavanderHair
        att2.Rotation = Vector3.new(0, 0, 0) --LavanderHair
        elseif Key == "m" and Mode == 5 then
  Mode = 1
  ModeName.Text = "Sinner"
  ModeName.TextStrokeColor3 = Color3.fromRGB(255,255,255)
  omgitskorn.OutlineColor = Color3.fromRGB(255,255,255)
  KillBot:Stop()
  Sinner:Play()
  att2.Parent = cplayer["Right Arm"]
  att2.Position = Vector3.new(-0.5, -3, -0.3)
  att2.Rotation = Vector3.new(35, 90, 0) --LavanderHair
 end
end)

while true do
   swait()
 sine = sine + change
 local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
 local velderp = root.Velocity.y
 hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
  if 1 < root.Velocity.y and hitfloor == nil then
   Anim = "Jump"
   if attack == false and Mode == 1 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.5 - .5 * Cos(sine / 50)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3), Rad(0), Rad(25)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.5 - .5 * Cos(sine / 50), -.5* Player_Size) * LHCF * angles(Rad(-3), Rad(0), Rad(35)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.1 + 0.1 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(-65), Rad(-.6), Rad(0 + 10 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, -0.1 + 0.1 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-0 - 10 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 2 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.5 - .5 * Cos(sine / 50)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3), Rad(0), Rad(25)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.5 - .5 * Cos(sine / 50), -.5* Player_Size) * LHCF * angles(Rad(-3), Rad(0), Rad(35)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.1 + 0.1 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(-65), Rad(-.6), Rad(0 + 10 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, -0.1 + 0.1 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-0 - 10 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 3 then
       rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 3 + 0.5 * Cos(sine / 50)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 15 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(1 + 0 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-5 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 4 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 50)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 50), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(90 + 10 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-0 - 10 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 5 then  
             rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 50)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 50), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(30 + 10 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-30 - 10 * Sin(sine / 20))), 0.1)
         end
         
  elseif -1 > root.Velocity.y and hitfloor == nil then
   Anim = "Fall"
   if attack == false and Mode == 1 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(0 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-35 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 2 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(0 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-35 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 3 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 3 + 0.5 * Cos(sine / 50)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 15 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(1 + 0 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-5 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 4 then
          rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 1* Player_Size * Cos(sine / 12)) * angles(Rad(-10), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(0), math.random()), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.55 - 0.1 * Cos(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.6 - 0.2 * Cos(sine / 50)* Player_Size, -0.2* Player_Size) * angles(Rad(-40), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.2 * Sin(sine / 50)* Player_Size, 1* Player_Size) * angles(Rad(-140), Rad(-4 + 6.5 * Sin(sine / 12)), Rad(-90)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(9 - 6.5 * Sin(sine / 12)), Rad(-15)), 0.1)
   elseif attack == false and Mode == 5 then  
             rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
      end
     
  elseif torvel < 1 and hitfloor ~= nil then
   Anim = "Idle"
   change = 1
   if attack == false and Mode == 1 then  
   change  = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0 + 0.05* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(7)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -16)), Rad(0), Rad(-10)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - -0 * Cos(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(65), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -1 - -0 * Cos(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0 + 0 * Sin(sine / -30)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(6 + 6.5 * Sin(sine / 12)), Rad(-0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-0.5* Player_Size, 0 + 0 * Sin(sine / 30)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(6 - 6.5 * Sin(sine / 12)), Rad(90)), 0.1)
   elseif attack == false and Mode == 2 then
   change = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(7)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(2 * Sin(sine / -12)), Rad(0), Rad(-10)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / -30)* Player_Size, 0* Player_Size) * angles(Rad(-75), Rad(6 + 6.5 * Sin(sine / 12)), Rad(-10)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 30)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(6 - 6.5 * Sin(sine / 12)), Rad(-10)), 0.1)
   elseif attack == false and Mode == 3 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 3 + 0.5 * Cos(sine / 50)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(1 - 15 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(1 + 0 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-5 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 4 then 
      rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 1* Player_Size * Cos(sine / 12)) * angles(Rad(-10), Rad(0), Rad(0)), 0.1)
      tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(0), math.random()), 0.1)
       RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.55 - 0.1 * Cos(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(50), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
          LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.6 - 0.2 * Cos(sine / 50)* Player_Size, -0.2* Player_Size) * angles(Rad(-40), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
          RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.2 * Sin(sine / 50)* Player_Size, 1* Player_Size) * angles(Rad(-140), Rad(-4 + 6.5 * Sin(sine / 12)), Rad(-90)), 0.1)
       LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(9 - 6.5 * Sin(sine / 12)), Rad(-15)), 0.1)
   elseif attack == false and Mode == 5 then  
      rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(0), Rad(-20)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 100)* Player_Size, -0.2* Player_Size) * angles(Rad(10), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(6 + 6.5 * Sin(sine / 12)), Rad(0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, -0.5* Player_Size) * angles(Rad(190), Rad(6 - 6.5 * Sin(sine / 12)), Rad(45)), 0.1)
   end
   
  elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
   Anim = "Walk"
   if attack == false and Mode == 1 then
       change = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-0) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 30 + -Sin(sine / 7) / 2, Rad(65 - 20 * Cos(sine / 7)), Rad(10)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 + 0 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 30 + Sin(sine / 7) / 2.5, Rad(-65 - 20 * Cos(sine / 7)), Rad(10)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 100)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(6 + 6.5 * Sin(sine / 12)), Rad(30)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0 + 0.0* Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(90 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
              elseif attack == false and Mode == 2 then
               change = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 + 0 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(-60), Rad(6 + 6.5 * Sin(sine / 12)), Rad(0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0 + 0.0* Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(35 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
              elseif attack == false and Mode == 3 then
               rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 3 + 1.5 * Cos(sine / 50)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(-35)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(15)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-0), Rad(-.6), Rad(15 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(-.6), Rad(-5 - 4.5 * Sin(sine / 20))), 0.1)
    elseif attack == false and Mode == 4 then  
          rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 1* Player_Size * Cos(sine / 12)) * angles(Rad(10), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), math.random(), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.55 - 0.1 * Cos(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(-55), Rad(45), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.6 - 0.2 * Cos(sine / 50)* Player_Size, -0.2* Player_Size) * angles(Rad(-25), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.2 * Sin(sine / 50)* Player_Size, 1* Player_Size) * angles(Rad(-90), Rad(-4 + 6.5 * Sin(sine / 12)), Rad(-90)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(45), Rad(9 - 6.5 * Sin(sine / 12)), Rad(-15)), 0.1)
   elseif attack == false and Mode == 5 then  
       rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2.5, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)  
     RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(120)  * Cos(sine / 7) , Rad(9 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 90), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-120)  * Cos(sine / 7) , Rad(0 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
   end
  elseif torvel >= 22 and hitfloor ~= nil then
   Anim = "Sprint"
    change = 1.35
   if attack == false and Mode == 1 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-50 - 50 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 + 0 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-50 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(6 + 6.5 * Sin(sine / 12)), Rad(0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0 + 0.0* Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(35 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
     elseif attack == false and Mode == 2 then
               change = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 + 0 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(-60), Rad(6 + 6.5 * Sin(sine / 12)), Rad(0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0 + 0.0* Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(35 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
   elseif attack == false and Mode == 3 then
   -- copy and pasted my walk cause i didnt see a reason to make a sprint, fall or jump on mode 3
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 3 + 1.5 * Cos(sine / 50)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(-35)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(15)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-0), Rad(-.6), Rad(15 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(-.6), Rad(-5 - 4.5 * Sin(sine / 20))), 0.1)
     elseif attack == false and Mode == 4 then  
          rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-10) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(0)  * Cos(sine / 7) , Rad(9 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 90), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(0 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
     elseif attack == false and Mode == 5 then  
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2.5, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
     RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(120)  * Cos(sine / 7) , Rad(9 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 90), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-120)  * Cos(sine / 7) , Rad(0 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1) 
             end
          end
       end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
 